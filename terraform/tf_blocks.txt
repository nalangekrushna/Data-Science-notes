terraform blocks

.terraform.lock.hcl file should be included in version control. As lock file contains exact version of providers(plugins) that can be useful to reproduce the environment. Currently tf don't track modules (groups of terraform configuration construct). This file is stored in root module (where we run tf commands) and applicable to root module as well as all sub-modules.

.terraform directory contains all the downloaded modules and providers. This directory should be ignored in version control.

terraform State = tf stores information about infrastructure in a state file. This state file keeps track of resources created by your config and maps them to real world resources. By default tf creates a terraform.tfstate file locally and stores it there. This file should be ignored in git as it can contain your passwords and secrets. the best practise is to use terraform remote state with encryption enabled at transit and rest. 
There are following issues with storing terraform state file in version control
	1. If you forget to commit and push changes after running tf apply, your team mates will have out of sync tfstate file.
	2. Also two team mates can run terraform at same time and overwrite each others changes.
	3. Also tfstate file may also contains secrets like aws_db_instance password.

terraform.tfstate.backup = By default a backup of your state file is writtern to terraform.tfstate.backup in case of state file is lost or corrupted to simplify the recovery. Every time you run tf apply it will create a new terraform.tfstate file and rename old file to terraform.tfstate.backup . This file also should be ignored in version control.

tfplan = This file contains execution plan to update resources. This file can be generated by using tf apply -out=./tfplan command. This file should be ignored in vcs.

tf workspaces = tf workspaces works differently in CLI and tf cloud. tf workspaces are required in cloud while they are optional in cli. Also cli creates a workspace named "default" by default. Workspaces can be used have different instances of tfstate with same config. workspaces can be used to test new infrastructure before going live on prod.

terraform didn't support single quotes. Doubel quotes only. Also terraform is case-sensitive.

terraform locals vs (input/terraform) Variables
locals are only accessible within local modules while variables can be scoped globally. Consider variables as input paramteres in a function call. Also locals don't change there value once initialized/assigned while variables values can be manipulated by expressions. 

Output values = Output values make information available about your infrastructure available on command line can expose information for other terraform configuration to use. Output values are similar to functions return values in programming languages. use cases for output values are 1) child module can expose subset of its resource attribute to parent module. 2) A root module can use outputs to print certain values on CLI. 

tf backends = Following backends are supported by terraform : local(defalt), remote, artifactory, azurerm, consul, cos, etcd, etcdv3, gcs, http, kubernetes, manta, oss, pg, s3 and swift

In tf backend when some or all of the arguments are omitted, we call it partial config. remaining arguments can be provided by file, cli or interactively. If partial config is specified then you atleast need to define empty backend block with backend name. eg.
terraform {
  backend "consul" {}
}

terraform fuctions = most of the terraform functions are pure functions. (ie. output only depends on input arguments.) But there is a small set of special functions such as timestamp, uuid, file and templatefile which interacts with outside resources. timestamp and uuid will produce different results everytime you run it so for plan stage both this outputs "unknows" so at apply time result will match with real world. file and templatefile are used to read inital config on disk so you cannot use them to read dynamically generated files as it only runs at init time.

splat expression = splat expression is shorthand alternative to for expression. Splat experssion can be used with list set and tuple. splat expression treats single value other than "null" as a list with single element. If value is null then splat expression will return an empty tuple. Splat only works with for expression and not when for_each expression is being used. e.g.
[for o in var.list : o.id] it's equivalent splat function as below.
var.list[*].id

Python supports following data types
string, number, bool, list, map, set, object and tuple

dynamic block = dynamic block acts like a for expression and produced nested blocks.

for expression vs for_each meta-arguments :
https://awstip.com/terraform-for-vs-for-each-7ff8506a1f94




