AWS misc 

Permission policies = You manage access in AWS by creating permission policies and attaching them to IAM identities (users, groups of users, or roles) or AWS resources. AWS evaluates these policies when an IAM principal (user or role) makes a request. Most policies are stored in AWS as JSON documents. There are 6 types of policies
1. Identity-based policies – Attach managed and inline policies to IAM identities (users, groups to which users belong, or roles). They can be further categorized as 
	a. Managed Policies = can be further classified as
		i. AWS managed
		ii. Customer managed
	b. Inline policies = tightly coupled with either single user,user group or role. gets deleted when coupled entity is deleted.

2. Resource-based policies – Attach inline policies to resources. e.g. permission of s3 bucket.
3. Permissions boundaries – Use a managed policy as the permissions boundary for an IAM entity (user or role). That policy defines the maximum permissions that the identity-based policies can grant to an entity, but does not grant permissions. 
4. Organizations SCPs – Use an AWS Organizations service control policy (SCP) to define the maximum permissions for account members of an organization or organizational unit (OU). SCPs limit permissions that identity-based policies or resource-based policies grant to entities (users or roles) within the account, but do not grant permissions.
5. Access control lists (ACLs) – ACL does not use the JSON policy document structure. ACLs are cross-account permissions policies that grant permissions to the specified principal.
6. Session policies – Pass advanced session policies when you use the AWS CLI or AWS API to assume a role or a federated user. Session policies limit permissions for a created session, but do not grant permissions.

example of aws json policy
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": "*",
            "Resource": "*"
        }
    ]
} 

at top level contains policy wide applicable optional elements.
version = As a best practice, use the latest version.
Statement = list of container for following elements.
	Sid(Statement id)(optional) = to differentiate between different policy statements.
	Effect – Use Allow or Deny to indicate whether the policy allows or denies access.
	Principal(only for resource based policy) = If you create a resource-based policy, you must indicate the account, user, role, or federated user to which you would like to allow or deny access. 
	Action – Include a list of actions that the policy allows or denies.
	Resource (Required in only some circumstances) – If you create an IAM permissions policy, you must specify a list of resources to which the actions apply. If you create a resource-based policy, this element is optional. If you do not include this element, then the resource to which the action applies is the resource to which the policy is attached.
	Condition (Optional) – Specify the circumstances under which the policy grants permission.

Ephemeral Ports = The ephemeral ports are the short-lived transport protocol ports for Internet Protocol (IP) communications. Ephemeral ports are allocated automatically from a predefined range by the IP stack software. An ephemeral port is typically used by the Transmission Control Protocol (TCP), User Datagram Protocol (UDP) or the Stream Control Transmission Protocol (SCTP) as the port assignment for the client end of a client-server communication to a well-known port on a server. 
What that means is, when a client initiates a request it choose a random port from ephemeral port range and it expects the response at that port only. Take note of the below statement:
When we say that the client initiates an HTTPs or HTTP request it actually means that the destination port is 443 or 80. It is NOT the sender port.
It is the client’s operating system that chooses the sender’s port from the ephemeral port range and this range varies depending on the OS. 
For HTTPS, the outbound rule in our case allows the response at port 443. Now, this doesn’t allow outbound HTTPS traffic because that is not the port from which request was initiated. For the request to succeed we would have to set Outbound Port Range to 1024-65535 and NOT to 443.
As discussed above, the client that initiates the request chooses the ephemeral port range. So in order to allow outbound IPv4 responses to clients, for example serving web pages to people visiting the web servers in the subnet, you need to allow traffic through the ephemeral ports depending on the clients.